# from fastapi import FastAPI
# from fastapi.middleware.cors import CORSMiddleware
# from pydantic import BaseModel
# from typing import List, Optional
# from sse_starlette.sse import EventSourceResponse
# import requests, ast, operator as op, json, asyncio

# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# # ---------- Math: safe evaluator ----------
# ops = {
#     ast.Add: op.add, ast.Sub: op.sub, ast.Mult: op.mul, ast.Div: op.truediv,
#     ast.USub: op.neg, ast.FloorDiv: op.floordiv, ast.Mod: op.mod, ast.Pow: op.pow,
# }
# def _eval(node):
#     if isinstance(node, ast.Num):  # py<3.8 compatibility
#         return node.n
#     if isinstance(node, ast.UnaryOp) and type(node.op) in ops:
#         return ops[type(node.op)](_eval(node.operand))
#     if isinstance(node, ast.BinOp) and type(node.op) in ops:
#         return ops[type(node.op)](_eval(node.left), _eval(node.right))
#     raise ValueError("disallowed")
# def eval_math(expr: str):
#     try:
#         # allow digits and common math symbols only
#         if not all(c.isdigit() or c in "+-*/(). ^% " for c in expr):
#             return None
#         tree = ast.parse(expr.replace("^", "**"), mode="eval")
#         return _eval(tree.body)
#     except Exception:
#         return None

# # ---------- Science: Wikipedia summary ----------
# def wikipedia_summary(query: str) -> Optional[str]:
#     # Build a Wikipedia REST Summary URL; encode safely
#     slug = query.strip().replace(" ", "_")
#     url = f"https://en.wikipedia.org/api/rest_v1/page/summary/{requests.utils.quote(slug)}"
#     try:
#         r = requests.get(
#             url,
#             headers={"User-Agent": "multi-llm-agent-demo/1.0"},
#             timeout=6,
#         )
#         if r.status_code == 200:
#             data = r.json()
#             # prefer 'extract'; fallback to 'description'
#             text = data.get("extract") or data.get("description")
#             if text:
#                 # Trim overly long responses for UI friendliness (optional)
#                 if len(text) > 1200:
#                     text = text[:1200].rsplit(" ", 1)[0] + " ..."
#                 return f"{text}\n\nSource: Wikipedia"
#         # 404 or other: return None so caller can decide message
#         return None
#     except requests.RequestException:
#         return None

# # ---------- Models ----------
# POOL = [
#     {"name": "Model A", "specialty": "Math"},
#     {"name": "Model B", "specialty": "Science"},
#     {"name": "Model C", "specialty": "Reasoning"},  # optional
# ]

# class RunAgentReq(BaseModel):
#     query: str
#     models: Optional[List[str]] = None

# class FeedbackReq(BaseModel):
#     model: str
#     feedback: str

# # ---------- Non-streaming (fallback & easy mode) ----------
# @app.post("/api/run-agent")
# def run_agent(body: RunAgentReq):
#     chosen = [m.copy() for m in POOL if not body.models or m["name"] in body.models]

#     for m in chosen:
#         if m["name"] == "Model A":
#             res = eval_math(body.query)
#             m["initial_output"] = f"Parsed arithmetic expression: {body.query}"
#             m["final_output"] = f"Computed result = {res}" if res is not None else "Could not compute a numeric result."

#         elif m["name"] == "Model B":  # Science via Wikipedia
#             summary = wikipedia_summary(body.query)
#             m["initial_output"] = f"(Science) researched: {body.query}"
#             m["final_output"] = summary or "No article found."

#         else:  # Reasoning (optional)
#             m["initial_output"] = f"Outlined a reasoning plan for: {body.query}"
#             m["final_output"] = "Resolved minor inconsistencies and highlighted key caveats."

#     synthesized = "Final combined answer: " + " ".join(
#         (m.get("final_output") or "")[:140] for m in chosen
#     )
#     return {"models": chosen, "synthesized_insight": synthesized}

# # ---------- Streaming (SSE) ----------
# @app.get("/api/run-agent/stream")
# async def run_agent_stream(query: str, models: Optional[str] = None):
#     selected = [s.strip() for s in (models or "").split(",") if s.strip()] or [m["name"] for m in POOL]
#     chosen = [m.copy() for m in POOL if m["name"] in selected]

#     async def event_gen():
#         # Step 1: assignment
#         yield {"type": "timeline", "title": "Assigned tasks to selected models", "note": ", ".join(selected)}
#         await asyncio.sleep(0.3)

#         # Step 2: initial outputs (per model)
#         for m in chosen:
#             if m["name"] == "Model A":
#                 m["initial_output"] = f"Parsed arithmetic expression: {query}"
#             elif m["name"] == "Model B":
#                 first = wikipedia_summary(query) or "No concise entry found."
#                 m["initial_output"] = first
#             else:
#                 m["initial_output"] = f"Outlined reasoning plan for: {query}"
#             yield {"type": "model_update", "model": m["name"], "field": "initial_output", "value": m["initial_output"]}
#             await asyncio.sleep(0.2)

#         yield {"type": "timeline", "title": "Cross-review & collaboration", "note": "Models read each other and refine"}
#         await asyncio.sleep(0.5)

#         # Step 3: final outputs
#         for m in chosen:
#             if m["name"] == "Model A":
#                 res = eval_math(query)
#                 m["final_output"] = f"Computed result = {res}" if res is not None else "Could not compute a numeric result."
#             elif m["name"] == "Model B":
#                 txt = m.get("initial_output") or wikipedia_summary(query) or ""
#                 m["final_output"] = (txt + "\n\n(Checked for obvious contradictions.)").strip()
#             else:
#                 m["final_output"] = "Resolved minor inconsistencies and highlighted key caveats."
#             yield {"type": "model_update", "model": m["name"], "field": "final_output", "value": m["final_output"]}
#             await asyncio.sleep(0.2)

#         yield {"type": "timeline", "title": "Synthesizer merged results", "note": "Conflicts resolved, caveats added"}
#         synthesized = "Final combined answer: " + " ".join((m["final_output"] or "")[:140] for m in chosen)
#         yield {"type": "final", "models": chosen, "synthesized_insight": synthesized}

#     async def sse_iterator():
#         async for ev in event_gen():
#             yield f"data: {json.dumps(ev, ensure_ascii=False)}\n\n"

#     return EventSourceResponse(sse_iterator())

# @app.post("/api/feedback")
# def feedback(body: FeedbackReq):
#     print("Feedback:", body.model, body.feedback)
#     return {"status": "ok"}
